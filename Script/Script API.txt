
Intro
=====
Flexible Editor is written in C++ using Qt 4.8.0.
The scripts are written in JavaScript. The standard is restricted to
ECMAScript 2009 (ES5), since newer standards is not supported by Qt 4.8.

Currently, scripts are used to set up and handle all UI interaction in the
editing window for data items selected from the database tree.
Each script file in the Script/Type subfolder corresponds to a data type.

This means it's possible to modify the scripts or create entirely new ones.
So long as the editor finds a .js file corresponding to the TYPE attribute, it will load it.

Inclusion
=========
To include another script file, place in a comment for every script you
want to include:

//FLEX_INCLUDE "filename.js".

Paths are relative to the default script folder, but can also be absolute.
This can be anywhere in the script file, inclusion is handled
before the script is evaluated or run in any way.

It is also possible to do it without using comments, for example:

FLEX_INCLUDE = "file1.js"
FLEX_INCLUDE = "file2.js"

It needs to be within "" quotes.

Data type scripts
=================

The script must contain the function init(), that is the only requirement.
init() is called when an item's window is initialized. Everything happens from there.

In order to display the default controls that's usually shown at the top,
you can include "common_default.js" and call "DefaultControls.init()" in the init function:

//FLEX_INCLUDE "common_default.js"

function init() {

	DefaultControls.init();

}

Instead of writing everything from scratch you may be able to use one of the scripts that already exists as template or example, if the core idea is similar.
You can include scripts for some general handlers. These all start with "common_" in the filenames.
For example, for palettes, Check out "common_palette.js" or the scripts that includes it.

initFetch / Data fetch function
-------------------------------

The script can have a function, initFetch, that returns an array of data based on an XML element,
for that data to be used by other scripts. In this environment, all "Core" functions and other
works the same way, except that GUI elements can't be created.
An example of this functionality being used is when a PALETTE element is placed under an ITEM element
with "CHR_" data type.

Example:

function initFetch() {

	//Return an array of 10 elements where each contains a byte of data

	var returnArray = [];
	for (var a = 0; a < 10; a++) {
		var byteData = Core.getByte(a);
		returnArray.push(byteData);
	}

	return returnArray;
} 

Creating Q widgets (controls)
-----------------------------

New-able objects are available that wraps the functionality of Qt widget classes.
These can be added to the editing window by creating them with "new"
and setting their properties, and so on.
Here is a simple example on creating a widget for editing text:

	ctrlEdit = new QLineEdit(Core.window);
	ctrlEdit.setText("I can has cheezburger?");
	ctrlEdit.move(10, 10);
	ctrlEdit.show();

Core.window is an object pointing the editing window,
a parent object must be passed in the QLineEdit constructor
(and in the constructor of any other control you wish to add).
It is also possible to pass another control object as the parent in the constructor,
but I'm not sure there's any use for that possibility.

The following Qt Widgets can currently be created:

QLabel
QLineEdit
QPlainTextEdit
QComboBox
QPushButton
QFrame
QSlider
QCheckBox
QSpinBox
QTimer . . . (added for 260205)

These are all members of the global object.

(Beware that it gets a bit technically steep from here.)
Qt allows accessing all the properties, as well as "signals" and "slots" of these classes and its parent classes.
However, regular *methods* is not available to scripts by default, which complicates things a lot
as some of them are essential.
To overcome that problem, some methods have been reimplemented in a subclass
so that they can be called from the script after all. (using Q_INVOKABLE)

Here is an overview of which methods/functions have been made invokable:

Functions for classes that inherit QWidget (available for all widgets):

void	move(int x, int y)
void	setGeometry(int x, int y, int w, int h)
void	resize(int w, int h)

QLineEdit functions:

void	setAlignment(int flag) <- Qt::Alignment value is set using an Int.

QComboBox functions:

void	addItem(const QString &text)

QFrame functions:

void	setFrameStyle(int style)

QSlider functions:

void	setRange(int min, int max)
void	setSingleStep(int value)
void	setPageStep(int value)
void	setOrientation(int orientation) <- Qt::Orientation value is set using an Int.
void	setValue(int value)

Documentation for Qt classes, including for widgets, can be found here:
https://doc.qt.io/archives/qt-4.8/classes.html

Documentation for QWidget, base class for all Qt widgets:
https://doc.qt.io/archives/qt-4.8/qwidget.html

BitmapView object
-----------------
BitmapView is a new-able object for setting up a graphical UI or displaying graphics.
In the C++ code, it is a subclass of QGraphicsView that additionally encapsules a QGraphicsScene, QImage, and QPixmap
into the same object, handling them internally and simplifying drawing and displaying a single 24bpp bitmap of
desired width and height.
This means QGraphicsView properties, slots and signals are available.

Essential QWidget methods like move(x, y) and resize(w, h) are also available here.

In addition, BitmapView has these methods specific to it:

void	init(aWidth, aHeight)		Use this to initialize the BitmapView after constructing it.
void	refresh()			Use this whenever changes have been made to the bitmap.
void	setPixel(y, x, rgb24)
void	drawLineX(y, x1, x2, rgb24)
void	drawLineY(y1, y2, x, rgb24)
void	drawBox(y1, y2, x1, x2, rgb24)
void	drawBuffer(y1, y2, x1, x2, buffer)	Draws data from the array "buffer" where each element represents a
						rgb24 pixel, in order from top-left to bottom-right.
						Using this is much faster than calling setPixel or
						drawBox a dozen times to draw the same thing.
						(Added 260131)

(rgb24 is an int containing all 24 bits of the RGB values combined.)

The control has the following Signals that can be connected to functions:

void	mousePress(button, y, x)
void	mouseMove(button, y, x) . . . (Added 260109)
					Note: mouseMove is only emitted if a button is held down.

Connecting functions to signals
-------------------------------

Qt widgets will emit various "signals" upon events, like user interaction.
You can set up functions to be called on those events.
For example, this will set up a QLineEdit widget object, and a function
that is called when text has been edited.

myObject.prototype.createEdit = function() {
	this.editCtrl = new QLineEdit(Core.window);
	this.editCtrl.textEdited.connect(this, this.editTextFunc);
	this.editCtrl.show();
}
	
myObject.prototype.editTextFunc = function(a_newtext) {
	//handle edit event
}

Element Index
-------------

Scripts are usually tied to the XML Element with ITEM tag that the user just opened in the editor.
Functions like Core.getByte() and Core.setByte() are available that reads and writes data
from and to the binary relative to the pointer described by PTR and RELPTR attributes and so on.

Often the script only needs to concern itself with that XML Element, but some times references
to other elements in the XML is involved.
Most elements in the XML will get an unique Index when it is parsed.
(This is not related to "id" attribute, if present any any Element)
When "Element Index" is mentioned in this document, it refers to this index.


Global Objects
==============

Object Core

	Various essential functions and variables.

Object Event

	Object for global event dispatch and event function system.

Core object members
===================

Number base_y
Number base_x

	Used to keep track of the next Y and X pixel locations to add a control.
	This is reset when a new Item window is opened to Y=12 and X=15 by default.
	When adding controls, you probably want to use these when positioning the control.
	Then you can add to these variables for your own purposes or to make things work
	together with other script code.
	base_y is the important one to consider.
	(for example, add to base_y, the height of the control you just added, plus some empty space).

Number defaultIntSize

	Default Integer size. This is 16 unless the loaded XML changes it with the
	INTSIZE attribute in INFO element.

Array(192) NESPalette

	Access a NES Palette. Each index is a Number that represents a byte in the palette file (3 bytes for each color).

Number elmRefIndex

	Internal variable used to keep track of which XML Element the current script environment is related to.

Number versionDate

	Date for the build of Flexbile Editor in the format YYMMDD as a Number.
	The idea is that scripts can check this in order to skip code that makes use of API features not
	supported by an earlier (or not yet released) build.
	This number corresponds to the "build" number shown in the title bar.

For use within Data Type scripts
--------------------------------

QWindow window

	Object that wraps the QWindow of the current item.
	Used when creating new controls, this is passed as argument in the constructor.

Number winpal.bgcolor

	Get the window (background) color of the editing window, represented as a 24 bit (8+8+8) value.
	(You can't set it however)

void setByte(Number index, Number value)

	Write byte for the current Item, at active pointer + index.

Number getByte(Number index)

	Get byte for the current Item, at active pointer + index.

void setByteAbs(Number pointer, Number value)    (Added 251112)

	Write byte to binary at absolute pointer.

Number getByteAbs(Number pointer)    (Added 251112)

	Get byte from binary at absolute pointer.

Number getBinarySize() . . . (Added 251201)

	Get the file size of the loaded binary.

Number getActivePtr() . . . (Added 251202)

	Get the calculated active pointer for current Item (position read/written by getByte() and setByte())

Bool hasAttr(String name)

	Check if the Item element contains attribute 'name'.

String getAttr(String name)

	Returns the value of Item element attribute 'name' as a string.

Number getHexValueAttr(String name)

	Returns the attribute 'name' as a value, assuming it is hexadecimal number in the XML.

Bool getFlag(String flagname)

	Checks FLAG attribute in the Item element and returns true if 'flagname' is found in it. 

void setArrayIndex(Number index)    (Added 250823)

	Set current array index if Item element is an array.
	
Number getArrayIndex()    (Added 250823)

	Get current array index if Item element is an array.

void setArrayByteSize(Number bytes)    (Added 250823)

	Set the byte size of each index in the array. The default is 1.

Bool hasText()

	Check if the item element has text. (If anything is contained within <item> </item>)

String getText()

	Obtain the element's text.

Number childElementIndex(String tagName)    (Added 260129)

	Find first child element of current Item element that has the tag name (tagName),
	then return its Element Index.

Array fetchElementData(Number elmRefIndex)    (Added 260129)

	Get data from binary as described by an XML Element, with elmRefIndex as Element Index.
	(This is used by CHR_NES and CHR_SNES data types to get palette data through a PALETTE element)
	The Element must have a TYPE attribute and the TYPE must have an "initFetch" function
	in its corresponding script that returns an array of data.
	(Currently PAL_NES and PAL_15).
	You can use the "childElementIndex" function as a way to get the element index of a
	child element.

Array getList(String listname)

	Retrieve LIST element with key "listname" as an array of strings.

String loadTextFile(String filename)    (Added 250823)

	Load a text file as a String. "filename" must be absolute, or relative
	to the program folder, or relative to the currently open XML.

String stringDecode(Array byte_array, Number array_size, String encoding) . . . (Added 251205)

	Converts "byte_array" to a string of type "encoding".
	For "encoding", "UTF-8" is supported.
	"array_size" must contain the size of "byte_array".
	The function returns an object with two members:
		Object.data <- Resulting string
		Object.size <- Number of characters in string "data".

Object stringEncode(String string, Number string_size, String encoding) . . . (Added 251205)

	Converts "string" to an array of byte values encoded as "encoding".
	For "encoding", "UTF-8" is supported.
	"string_size" must contain the number of characters in "string".
	The function returns an object with two members:
		Object.data <- Array of resulting byte values.
		Object.size <- Number of elements (bytes) in "data".

String customize(String attributeName, String defaultValue, String 2ndPrioAttributeName) . . . (Added 260129)

	Convenience function for allowing users to customize the editing environment through XML attributes,
	usually graphically.	
	This also checks settings in the current Theme, so it's not good for other purposes.

	The logic is as follows:
	If the ITEM element has "attributeName" then the function will return that attribute, otherwise:
	If the ITEM element has "2ndPrioAttributeName" then the function will return that attribute, otherwise:
	If the current Theme has "attributeName" in its settings the function will return that value, otherwise:
	If the current Theme has "2ndPrioAttributeName" in its settings, the function will return that value..
	Otherwise, return "defaultValue".

	The distinction between the two attribute names is implemented in the case that this function is called
	from multiple instances or objects based on the same code, and that it should be possible to customize
	either ONE of the instances or all of them.
	For an abstract example:

	leftTextControl.color = Core.customize("lefttext.color", "FFBBAA", "text.color");
	rightTextControl.color = Core.customize("righttext.color", "AABBFF", "text.color");

	^ This allows the user to customize the "color" property of the left control and right controls
	individually through "lefttext.color" and "righttext.color" attributes respectively,
	but also both at the same time through the "text.color" attribute.
	If "text.color" is a setting set in the theme and none of the attributes are present in the Element,
	the function returns that setting.

	(Earlier version of this function is available undocumented since
	b250813 but the 3rd argument was added 260129).

Event object / Event object members
===================================

"Event" is an object a global event dispatch/handling system.
It has a function "dispatch" for dispatching an event.
It has one Qt Object signal simply named "signal", that can be connected to an event handler function.

Through this mechanism, scripts can communicate internally without being limited to specific functions, variables or Qt Object signals, or having to know their names.

When calling "dispatch" function, it takes one Value argument, containing event bits, from predefined or custum values.
Also, handler functions must take one Value argument for the event bits.

(For now, events is used by common_default.js when there is an Array index tuner and the
Array index is changed, and it dispatches "Event.bit.changeIndex".)


Dispatch example:

	//Dispatch this event to any handler functions connected to the event mechanism.

	Event.dispatch(Event.bit.changeIndex);

Handler function example:

	...
	//Connect signal to handler function
	Event.signal.connect(this, this.eventHandlerFunc);
	...

	//Handler function
	MyObject.prototype.eventHandlerFunc = function(a_event_bits) {
		if (a_event_bits & Event.bit.changeIndex) {
			//Update all GUI elements relevant to arrays
			...
		}
	}


Values for Object "bit":

	Event.bit.changeIndex = 1	Array index has been changed.
	Event.bit.changeMajor = 2	Major change, the script should update all GUI.
	Event.bit.user = 256		User bits can be defined from here (bit 8) and up.
