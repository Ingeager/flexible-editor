
Update Notes
============

Release 2026-02-05:
 - Added CHR_NES and CHR_SNES data types.
 - Added PALETTE Element, that can be placed as child elements of CHR data types.
 - Added STRING_UTF8 data type.
 - Added SNAPX, SNAPY, GRIDX and GRIDY attributes for COORDINATE data type.

Script Update Pack 2025-12-22:
 - Added BIGENDIAN flag for Integer types.
 - Added LAB Item attribute.
 - Palette types now has a page selector and can be larger than 256 entries.
 - Added PAL_32 Type (RGBA8888), also added PAL32_ABGR, PAL32_ARGB and PAL32_BGRA.
 - Added PAL_24BGR Type (BGR888)
 - Added PAL_15A Type (RGB555 with MSB as Transparency toggle)
 - Added BGR Flag for all Palette types.
 - Bugfix: Integers: Bit editing controls and List control now reflect each other's changes.

DRDXML format - Introduction
============================

Flexible Editor makes use of "data-reference databases" (DRD) written in XML format.
These databases basically describe the location and types of datas in a file.

XML files can be written outside the editor and then loaded, it also has some
simple features for creating and editing them.
As required by the XML standard, the XML must have a root element that contains all
elements in the document.

Here's a basic example of a XML file that Flexible Editor can load:

<drd>
    <item name="Data" ptr="FA0" type="byte"/>
</drd>

"drd" is just a dummy element in order to have a root element. You can name this
whatever you like.
An "item" element describes one item in the database, or the database tree, or
a parent for other items.
The "ptr" attribute in the item element is the location of the data, in hexadecimal.
"type" describes the type of data.
Most attributes that have a numerical value is written in hexadecimal without a prefix.
But there are exceptions, where a decimal value is expected instead.

You can build a tree structure using the ITEM element, where some ITEM elements
function as containers, or parents of other items.
The ITEM element is not required to have any attributes.

Example:

<drd>
	<item name="Byte datas">
		<item name="Byte Data 1" ptr="FA0" type="byte"/>
		<item name="Byte Data 2" ptr="FA4" type="byte"/>
	</item>
	<item name="Word datas">
		<item name="Word Data 1" ptr="1B4C" type="int16"/>
		<item name="Word Data 2" ptr="1B50" type="int16" flag="SIGNED.DECIMAL"/>
	</item>
</drd>

If you want to make the parent elements more distinct from the others,
you can use BRA instead. It's interpreted exactly the same way as ITEM.

If you want to write an XML and want more examples, check out demo.xml.
It demonstrates an example for all data types.
Also, the "XML" subfolder will contain demos and examples.

The XML format is based on a format developed about 20 years ago for the program called "DRDHack".
Flexible Editor doesn't support everything that editor did yet, but the plan
is to make it fully compatible with .XML documents written for that.
That format will be referenced to as "2006 standard" some places in this document.

Supported Elements
==================

ITEM
----

ITEM is used to describe one item of data, or function as a
parent element for other Item elements.
It can describe various data types, or none (blank).
All attributes are optional, including the NAME attribute.

In an alternative case, an ITEM element describes a List Item element, this will be
described further down in the document.

Supported attributes for ITEM:

	NAME	Display name describing the Item, shown in the Item tree and window titles.
	TYPE	Data type. See further on for specifics, and which extra attributes
		you can specify depending on the Data type.
	PTR	Hexadecimal pointer to data (without prefix).
	RELPTR	Relative pointer to data, in Hexadecimal (without prefix).
		Assumes that a PTR is provided from a parent Item, or a COMMON element.
		If the parent Item is an array, the pointer will be relative to the offset of
		the parent Item's current index.
	LEN	Hexadecimal without prefix. This can be:
		1. Size of data for variable length data, such as Strings or Palettes.
		2. Size of array for fixed-length data that supports arrays. (Integers)
		3. Size of array for a parent Item without Type.
		(For 2 and 3, see "Arrays" section for more details.)
	FLAG	Define flags relevant to the data type. All flags you want to
		set is placed in this attribute, separated using a dot (.)
		Example: .. flag="DECIMAL.SIGNED" ..
	COMMON	Use a COMMON element as a template. (See "Common Element" section)
	ICON	Use a graphical icon for this Item in the Item Tree.
		Value must correspond to the KEY attribute from an ICON Element.
		(See "ICON Element" section)
	LAB	Display a comment. If present, it will be displayed in an edit control at the
		top of the editing window.

An Item for editing data will use either PTR or RELPTR.
(They can both be used, but there's not much point)
See the section on Pointers further on for more details.

Text: ITEM elements can contain a text part. This works exactly the same as the LAB attribute.
If it's present, it will be displayed in an edit control at the top of the editing window.

BRA
---

Describes a Branch.
Works exactly the same as ITEM, but was used in the 2006 standard
to exclusively describe a parent element (branch).
You can still use it if you want.

COMMON
------

Template for use with items. See "Common Element" section.

Supported attributes:
	KEY	Key used to reference to the Common element. Required.

NESPAL
------

Load a NES palette from a file to use in place of the default one.

Supported attributes:
	FILENAME	File path of the NES Palette file, can be relative or absolute.
			If it's relative, the editor will look in the same folder as the XML,
			then in the program folder, in that order of prority.

INFO
----

Descriptions and configurations relating to the whole document.

Supported attributes:

	INTSIZE		Set the default Integer size in bits. Relevant for INT data type.
			This is a decimal value.
			This can be any number divisible by 8.
			The actual upper limit hasn't been tested,
			but 512 appears to be fine.
			If this isn't set, it will be 16.

	HEADICON	Set an Icon as the app window icon, from an Icon Element.
			Must correspond to the KEY attribute of an Icon Element.
			(See "ICON Element" section)

LIST
----

Container parent element for all list items.
Each list is set up using an ITEM element. (See below :)

ITEM (List Item)
----------------

Each list has a Key attribute used as reference to it from data items where you wish to use the list.
The actual list contents is placed in the text part of this element.
Each list entry is placed within double quotes. (Line breaks are ignored)
Like this: "Entry 1" "Entry 2" "Entry 3" ...
When lists are used, values are automatically added to the start of the strings.

Supported attributes:

	KEY	Key (Name) used to refer to the list. Required.

A full example of a document using a list:

<drd>
	<item name="Data using a list" ptr="88" type="int8" list="example"/>
	<list>
		<item key="example">
			"Eat" "Sleep" "Code" "Repeat"
		</item>
	</list>
</drd>

You'll have 4 values to choose between corresponding to the 4 entries in the list named "example".

PALETTE
-------

"PALETTE" elements can be placed as a child of ITEM elements with CHR_NES and CHR_SNES data types,
to describe a source of Palette data to view and edit the tiles.
These Elements works like regular ITEM elements, except that only attributes related to retrieving the
data is relevant. (Attributes like "name" is ignored)

Examples 1 - NES - This will show the tiles using the palette data at 0x550-0x553.

	<item ptr="1800" type="chr_nes" len="100">
		<palette ptr="550" type="pal_nes" len="4">
	</item>


Examples 2 - SNES - This will show the tiles using the palette data at 0x66A00-0x66A1F.

	<item ptr="40200" type="chr_snes" len="100">
		<palette ptr="66A00" type="pal_15" len="10">
	</item>

In both cases, palette data is fetched as an array of 24-bit RGB color values.

(Note: This particular feature was added just before release and may have bugs)

Pointers (PTR/RELPTR/Arrays)
============================

To find the pointer to data, the editor first looks for PTR in the current Item element.
If it doesn't find it, it will dig through the parent elements of the item until it finds a PTR or the root element.
If it doesn't find a base pointer, it will just add everything relative to 0.

So you can for example do this:

<item ptr="4000">
  <item relptr="600">
    <item relptr="22"/>   <- Final pointer will be 0x4622
  </item>
</item>

This is also allowed and will have the same result:

<item relptr="4000">
  <item relptr="600">
    <item relptr="22"/>   <- Final pointer will be 0x4622
  </item>
</item>

If any of the Items contains an Array, a relative pointer will be added based on the current Array index.
(Index * index byte size).
The index byte size depends on the data type, or if it's blank/no type,
it is the contents of the ARR_INDEXWIDTH attribute.
See "Arrays" section for more details.

Data Types (TYPE attribute)
===========================

These are the data types that have basic or moderate support by Flexible Editor.

blank		No data type. This is the default if the TYPE attribute isn't specified.

Integer Types
-------------

byte		8 bit Integer.
int8		Same as byte, provided for completion.
int16		16 bit Integer.
int24		24 bit Integer.
int32		32 bit Integer.
int64		64 bit Integer.
int		General Integer, the bitsize is 16 by default and
		can be changed with the INTSIZE attribute:
		If it's in the same element it changes the intsize for that Item.
		If there's an INTSIZE attribute in the INFO element it sets it as a global default.

All integers are by default edited in Unsigned Hexadecimal in Little-Endian byte order.
This can be changed using the FLAG attribute and BASE attribute.

Supported attributes for Integer Types:
	INTSIZE		Decimal value. Change the Integer bitsize for any Integer type. This can be any
			number divisible by 8. The actual upper limit hasn't been tested,
			but 512 appears to be fine.
	LIST		Edit the integer using a List so each value is described with a string.
			This attribute refers to the KEY attribute of a list Item.
			Note that only 8 and 16 bit values
			are supported in this case. Bits higher than Bit 15 will be ignored both
			on Read and Write.
	BIT		Adds controls for editing/toggling the bits of the value.
			This attribute contains the label texts to describe each bit for
			each editing control.
			In order from MSB to LSB, text to describe each bit is placed
			separated using a dot/period. If a field is empty, the control
			won't appear.
			Example for "byte" or "int8" type:
			.. bit="Highest Bit.Bit 6.Bit 5.....Lowest Bit" ..
			^This will allow editing for Bits 7, 6, 5 and 0, but not bit 1 to 4.
	BASE		Edit Integer in a specific Base / Radix.
			Decimal value. This can be anything from 2 to 51.
			(DECIMAL flag will be ignored if this is set).
	LEN		Define an Array of integers where LEN is the Array length.
			Value is Hexadecimal without prefix.
			The total byte size of the array will be LEN * Integer byte size.

Supported flags for all Integer Types:
	SIGNED		Edit the integer as a Two's complement Signed value.
	DECIMAL		Edit the integer as a decimal (Base 10) number.
	BIGENDIAN	Edit the integer in Big-Endian mode.
			This also works for Bit toggling with BIT attribute and editing
			using a List.

	Examples:

 <item name="Potentially negative hex value" ptr="7F0" type="int24" flag="SIGNED"/>
 <item name="Potentially negative decimal value" ptr="7F3" type="int24" flag="SIGNED.DECIMAL"/>

Raw data types
--------------

hex	Edit bytes in hexadecimal, with 16 bytes on each row.

Supported attributes:
	LEN	Number of bytes in hex. For now, it is limited to somewhere around 1A0,
		depending on the screen resolution and how many rows will fit in the window.

String Types
------------

string		ANSI/Windows-1252 or ASCII string. Can be fixed-size or character code-terminated.
string_utf8	UTF-8 encoded string. Can have a fixed byte size or, the string can end at a
		specific character code.

Supported attributes:

	LEN		Sets byte size of data in Hexadecimal. For "string" type this is the
			same as the number of characters.
			For character code-terminated strings, this defines the maximum byte size
			of the input string + end character bytes.
			If the resulting data doesn't fit, characters from the input string are cut.

	ENDCODE		Defines the character code that ends/terminates the string.
			Decimal value.
			(Example: endcode="0")

Known bugs: There is a bug I've been unable to fix for now where the editor will crash, at least for
"string" in certain cases, though it seems related to unusual character codes.

Types: Graphics - Palette
-------------------------

pal_nes		NES Palette
pal_15		15 bit palette, 5 bits each for R, G and B. (RGB555)
		Use for SNES, GameBoy Color, GameBoy Advance.
pal_15a		Same as pal_15, but adds a 1-bit transparency toggle for the upper bit,
		making it suitable for PlayStation1 CLUT data.
pal_smd		Sega Mega Drive and Game Gear palette data. (RGB333)
pal_6		Sega Master System palette (RGB222)
pal_24		24 bit palette (RGB888), Red is first byte and Blue is the 3rd.
pal_24bgr	24 bit palette (BGR888), Blue is first byte and Red is the 3rd.
pal_32		32 bit palette (RGBA8888), with channels in order Red, Green, Blue, Alpha.
pal_32abgr	32 bit palette (ABGR8888), reverse of the above (Alpha, Blue, Green, Red)
pal_32argb	32 bit palette (ARGB8888), with channels in order Alpha, Red, Green, Blue.
pal_32bgra	32 bit palette (BGRA8888), with channels in order Blue, Green, Red, Alpha.

Supported attributes for all Palette Types:
	LEN	Number of palette entries in hexadecimal.
		If it's higher than 0x100 (256), a page selector is added.

Supported Flags for all Palette Types:
	BGR	Swaps the position of Blue and Red channels.

Supported objects for customization attributes, all CHR types (See "GUI Cusomization"):
	Type		Name

	GRID		grid		(all grids)
	GRID		entrygrid
	GRID		indexedgrid	Grid displaying indexed palette, such as for PAL_NES.

	(Example: entrygrid.selcolor="70C070" grid.color="007000")


Types: Graphics - CHR (Tiles)
-----------------------------

chr_nes		NES CHR (4 color 2bpp)
chr_snes	SNES CHR (limited to 16 color 4bpp for now)

Supported Attributes for all CHR Types:
	LEN		Number of tiles. For now, limited to the number of tiles
			that can be displayed in the window.
	PALETTE		Palette provided as 24-bit RGB values for each color.
			Each color value is written in hexadecimal and seperated by a dot,
			with channels in Red->Green->Blue order. Example:
			(palette="000000.FF0000.00FF00.0000FF")
			^ Provides a 4 color palette fit for NES CHR, with colors
			Black, Red, Green, Blue, in that order.
	SCALE		Set scaling of tile selector. Default is 3.
			The bigger, the larger. "1" will draw 1 screen pixel for each tile pixel,
			"2" will draw 2x2 pixels for each tile pixel, and so on.
			This must be an integer value.
	ROWLENGTH	Number of tiles in a row for the tile selector. Default is 16.
			(Decimal value)

Supported Child Elements for all CHR types:
	PALETTE		Use data from the binary as a palette source.
			Functions the same way as an Item element.
			Palette info is described using PTR, TYPE and LEN attributes.
			TYPE can be PAL_NES or PAL_15.

Supported objects for customization attributes, all CHR types (See "GUI Cusomization"):
	Type		Name

	GRID		grid		(all grids)
	GRID		tilegrid
	GRID		editgrid
	GRID		colorgrid

	(Example: tilegrid.selcolor="70C070" grid.color="007000")

Types: Graphics - Other
-----------------------

nes_nt_addr	NES NameTable Address. 16-bit, Big-endian address. (Upper byte first, then lower.)
snes_nt_addr	SNES NameTable Address. 16-bit, Little-endian address into a Nametable
		where each tile occupies 16 bits/2 bytes of data.
coordinate	Y and/or X coordinate data, 8-bit.


Supported attributes for SNES_NT_ADDR:
	BASE	Set the base VRAM address that the Nametable is supposed to start, in hex.
		The data value will then be read and written relative to this value.
		If this is not set, data is edited as the lower 11 bits
		(representing the 11 bits required to describe a typical address)
		and the upper bits are left alone.

Supported attributes for COORDINATE:
	Y	Enable Y editing. Value is relative byte pointer for the Y coordinate.
	X	Enable X editing. Value is relative byte pointer for the X coordinate.
	
	(You can define "y" to edit only Y coordinate,
	"x" to edit only X coordinate, or you can define both.)

	SNAPY	Decimal value. If set, Y coordinate will be rounded to values divisible by this value.
	SNAPX	Decimal value. If set, X coordinate will be rounded to values divisible by this value.
	GRIDY	Decimal value. If set, horizontal lines will be shown for every GRIDY pixel.
	GRIDX	Decimal value. If set, vertical lines will be shown for every GRIDX pixel.


Deprecated but Supported Data Types 
-----------------------------------

These are data types that are supported for compatibility with the 2006 standard,
but that I don't recommended using in newer documents.

listbyte	8 bit Integer editing using a list. You can simply use "byte" data type
		and provide a "list" attribute to reproduce it.
listint		Genereal Integer editing using a list. You can simply use "int" data type
		and provide a "list" attribute to reproduce it.
arr_byte	Array of Byte. Works the same as BYTE with LEN attribute set.
arr_listbyte	Array of Byte using list. Works the same way as BYTE with LEN and LIST attributes set.
arr_int		Array of Int. Works the same as INT type with LEN attribute set.
arr_listint	Array of Int using list. Works the same way as INT type with LEN and LIST attributes set.

Not yet supported
-----------------

These are data types that was specified in the DRD standard from 2006,
but has not yet been implemented in Flexible Editor.

tbl_string	String editing using a .tbl file.
		A work in progress script for this type is present, but it's early in development.


Arrays
======

If supported, setting the LEN attribute for a fixed-length data type will turn it into an Array.
(Currently the case for all Integers only).
A slider control will be added for changing the index.
Attributes ARRINDEX_LABLIST or ARRINDEX_LABDEF can be defined to give the
Array indexes string labels. In this case the index is changed using a dropdown list.
(See demo.xml for some examples.)

Array-specific Attributes:

	ARRINDEX_LABLIST	Define a List Item to be used to label the indexes in the Array.
				(Must match the KEY attribute of a List Item)
				The length of the list doesn't have to match the
				number of entries defined by LEN.

	ARRINDEX_LABDEF		Define labels for each Array index in an attribute.
				The labels are seperated with a . (dot)
				The number of labels defined doesn't have to match the
				number of entries defined by LEN.
	
	ARR_INDEXWIDTH		Hex value. Byte size of each array index.
				This can only be used for blank data types for now.
				(When parent items are set up as arrays)

Tables / Parent Item Arrays
---------------------------

Parent items with blank types can also be turned into an array using LEN,
where the child Items are relative to the current Index.
This can be used for editing tables with multiple instances of the same pattern of data.
The attribute ARR_INDEXWIDTH is used here to set the byte size of each index. (Default is 1)
Also, in the editor, the user must change the array index in the parent item,
then go to the individual child Items and change the actual data.

Parent Array Example:

In this example, let's say you have a table of stats for multiple player characters where for each
character there are 3 bytes: a 2-byte HP value and 1-byte "Class", and there are 0x20 (32) characters:

<item name="Character Table" ptr="8000" len="20" arr_indexwidth="3">
	<item name="Character HP" relptr="0" type="int16" flag="DECIMAL" />
	<item name="Character Class" relptr="2" type="byte" list="class"/>
</item>

^ Index 0 will start at offset $8000, Index 1 at $8003, and so on.
"Character HP" and "Character Type" uses RELPTR, which makes them relative to the current pointer
of the Parent Item. This way you can edit the HP and Class stats for all 32 characters without
creating XML Items for each one.

You can also create multi-dimensional arrays by turning multiple levels of parent Items into arrays.

ICON Element
============
The "icon" element loads a bitmap for use either as icons to represent Items in the tree structure,
or setting up a program icon in place of the default one.
The KEY attribute defines the Key to reference to it from Item elements, and FILENAME is the file name.
A variety of file types are supported, such as BMP and PNG.
The image files don't have to be a suitable size (they are stretched)
But for the Item Tree, the idea size is 16x16 pixels. They can also be transparent.
The placement of the ICON Element in the XML document doesn't matter.
These are parsed before everything else.

"filename" can be relative or absolute.
If it's relative, the editor will look in the same folder as the XML,
then relative to the program folder, in that order of prority.
The \Icons subfolder has some icons that could be used.

Document Example:

<drd>
	<item name="My data" ptr="0" type="int32" icon="myicon"/>
	<info headicon="myicon"/>
	<icon key="myicon" filename="C:\icons\myicon.bmp"/>
</drd>

^ This loads an icon and uses it both as the program icon and the icon for the single Item element.

COMMON Element
==============

A "common" element can be used as a template for attributes in Item elements.
(All attributes other than "key" is treated as if they're part of the Item)
These elements can be placed anywhere in the XML but it may look best if they're placed after all "item" ones.
They are referenced to by it's Key, set with attribute "key", which can be pretty much be anything you like.
To use it in a item element, add the attribute "common", that references the key.

Document Example:

<drd>
	<item name="Similar Data 1" ptr="140" common="data"/>
	<item name="Similar Data 2" ptr="180" common="data"/>
	<common key="data" type="int24"/>
</drd>

Both Items will have the data type "int24".

Advanced
--------
An Item element's attributes will have first priority. So if an attribute is found both in the Item
itself, and a COMMON element, the one from the Item will be used.

COMMON elements currently can't be nested (A COMMON element can't have a COMMON attribute.)


GUI Customization
=================
Some GUI elements in the editing window can be customized using attributes.
Some of these can be placed for all data types, and others are common between types or specific to
one data type.
(Note that all this is optional!)

List of general attributes:
---------------------------

window.stylesheet	Set a Style Sheet for the editing window. This will generally affect all
			controls in the window. If there's currently a theme active, this will
			override the theme.
color1			Theme color 1 in format "RRGGBB", channel values in hexadecimal.
			Currently changes the Horizontal line in Coordinate data types.
color2			Theme color 2 in format "RRGGBB", channel values in hexadecimal.
			Currently changes the Vertical line in Coordinate data types.
bgcolor			Theme bacground color 1 in format "RRGGBB", channel values in hexadecimal.
			Currently changes the background color of the display in Coordinate data type.


There are also "classes" where similar GUI elements are used for multiple data types,
some times with one instance and some times with multiple instances in the same window.
They can be customized through setting an attribute
for a specific property, in this format: instance.property="data"
The first part of the attribute describes the instance, followed by a period,
then the last part describes the property. (For example "tilegrid.color").
You can also use the general class name to change a property for all instances.
(For example "grid.color").

List of general classes:
------------------------

	EDIT

stylesheet	Set Style Sheet for all text editor controls.
		Setting the "edit.stylesheet" attribute will generally set a stylesheet for all
		controls in the window related to editing or displaying text.
		Currently, you can't set this for any specific instances anywhere.

	GRID

selcolor	Color of rectangle around selected entry in format "RRGGBB"
		where each channel is described with a Hexadecimal value between 00-FF.
color		Color of grid in format "RRGGBB"
		where each channel is described with a Hexadecimal value between 00-FF.
linewidth	Width of grid lines, in pixels.
lineheight	Height of grid lines, in pixels.

Style Sheets
------------

Style Sheets follow the convention in Qt 4.8 when the styleSheet property is set for a control.
General properties you can usually set is "background" for setting the background color or
background graphics, "color" for text color, and "font".

Example: edit.stylesheet="background: #203040; color: #6080A0; font: 18px"

Complete documentation for Qt Style Sheets can be found here:
https://doc.qt.io/archives/qt-4.8/stylesheet.html

Case Sensitivity
================
Generally speaking, Element tags are completely case insensitive. (You can do "ITem" and it should work)
For attributes, they need to be either Lower case or Upper case.

Customization / User Scripts for Data Types
===========================================

All UI code for data types is written in JavaScript / ECMAScript 5.
The scripts are found in the Script/Type subfolder.

When the editor sets up the editing windows, it reads the TYPE attribute,
then looks for a .js script file in that folder with a matching base name. (TYPE + ".js")

You can play around with the scripts, it's also possible to write your own scripts to create
user data types, though the features available are rather limited for now.
(See "Script/Script API.txt")

List of Changes and Additions from 2006 DRD standard
====================================================

* NAME is optional, and is auto-generated if left blank.
* TYPE was previously stated to be mandatory even though it wasn't and it made no sense that it should be when it's a parent ITEM or BRA.
	This has been changed so it's always optional, and when it's not present it's automatically defined as BLANK.
* BLANK Default Data Type, no data to edit but may contain PTR, and whatever else.
* In addition to BYTE and INT, which was previously rather ambiguous regarding size,
	specific-size INT data types from INT8 to INT64 are available.
* An assortment of new data types.
